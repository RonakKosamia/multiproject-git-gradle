/**
* multiproject-git-gradle/build.gradle
*
* Gradle script automating git-clone/pull and compilation of multiple 
* inter-connected projects.
*
* Written by Andrey Hihlovskiy (akhikhl AT gmail DOT com).
* Licensed under the MIT (http://opensource.org/licenses/MIT).
*
* @author Andrey Hihlovskiy
* @version 1.0.19
* @requires gradle 1.11+, git 1.8+
*
* Full documentation and sources at:
* https://github.com/akhikhl/multiproject-git-gradle
**/

buildscript {
  repositories { 
    jcenter()
    mavenCentral() 
  }
  dependencies { classpath 'org.ajoberstar:gradle-git:0.8.0' }
}

import org.ajoberstar.grgit.Grgit
import java.util.regex.Matcher

boolean isString(x) { 
  x instanceof String || x instanceof GString 
}

def isCollection(obj) {
  return [Collection, Object[]].any { it.isAssignableFrom(obj.getClass()) }
}

def toCollection(obj) {
  return isCollection(obj) ? obj : [ obj ]
}

class Project extends Expando {

  def releaseVersion
  def newVersion
  Boolean releaseNoCommit
  Boolean releaseNoPush

  Project() {
  }

  Project(Map properties) {
    super(properties)
  }
  
  void newVersion(String regex, Closure closure) {
    if(newVersion == null)
      newVersion = [:]
    newVersion[regex] = closure
  }
  
  void releaseVersion(String regex, Closure closure) {
    if(releaseVersion == null)
      releaseVersion = [:]
    releaseVersion[regex] = closure
  }
}

class MultiProjectExtension {
  def hostProject
  String rootFolder
  def projects = [:]
  String gitBase
  String gitNameSeparator = '/'
  String gitNameSuffix = '.git'
  def releaseVersion = [ /(\d+)([^\d]*$)/ : { Matcher m -> m.replaceAll(m[0][1]) } ]
  def newVersion = [ /(\d+)([^\d]*$)/ : { Matcher m -> m.replaceAll("${ (m[0][1] as int) + 1 }${ m[0][2] }") } ]
  Boolean releaseNoCommit
  Boolean releaseNoPush
  String branch
  
  def git(Map options = [:], Closure closure) {
    def savedGitBase = gitBase
    gitBase = options.baseUrl ?: options.baseDir
    def savedGitNameSeparator = gitNameSeparator
    gitNameSeparator = options.nameSeparator ?: options.gitNameSeparator ?: gitNameSeparator 
    def savedGitNameSuffix = gitNameSuffix
    gitNameSuffix = options.nameSuffix ?: options.gitNameSuffix ?: gitNameSuffix
    closure.delegate = this
    closure.resolveStrategy = Closure.DELEGATE_FIRST
    closure()
    gitNameSuffix = savedGitNameSuffix
    gitNameSeparator = savedGitNameSeparator
    gitBase = savedGitBase
  }
  
  boolean isString(x) { 
    x instanceof String || x instanceof GString 
  }  
  
  void newVersion(String regex, Closure closure) {
    newVersion[regex] = closure
  }
  
  def project(proj, Closure closure = null) {
    String projName = isString(proj) ? proj : proj.name
    if(projects.containsKey(projName))
      throw new Exception("Duplicate project definition: $projName")
    if(isString(proj))
      proj = new Project([ name: proj as String ])
    else
      proj = new Project(proj)
    if(closure) {
      closure.delegate = proj
      closure.resolveStrategy = Closure.DELEGATE_FIRST
      closure()
    }
    if(!proj.gitBase && !proj.gitSource)
      proj.gitBase = gitBase
    if(!proj.gitNameSeparator && !proj.gitSource)
      proj.gitNameSeparator = gitNameSeparator
    if(!proj.gitNameSuffix && !proj.gitSource)
      proj.gitNameSuffix = gitNameSuffix
    if(!proj.releaseVersion)
      proj.releaseVersion = releaseVersion
    else if(releaseVersion instanceof Map && proj.releaseVersion instanceof Map)
      proj.releaseVersion = releaseVersion + proj.releaseVersion
    if(!proj.newVersion)
      proj.newVersion = newVersion
    else if(newVersion instanceof Map && proj.newVersion instanceof Map)
      proj.newVersion = newVersion + proj.newVersion
    if(proj.releaseNoCommit == null)
      proj.releaseNoCommit = releaseNoCommit == null ? (hostProject.ext.has('releaseNoCommit') ? hostProject.ext.releaseNoCommit : false) : releaseNoCommit
    if(proj.releaseNoPush == null)
      proj.releaseNoPush = releaseNoPush == null ? (hostProject.ext.has('releaseNoPush') ? hostProject.ext.releaseNoPush : false) : releaseNoPush
    if(proj.branch == null)
      proj.branch = branch
    projects[projName] = proj
  }
  
  void releaseVersion(String regex, Closure closure) {
    releaseVersion[regex] = closure
  }
}

project.extensions.create 'multiproject', MultiProjectExtension
multiproject.hostProject = project
  
apply from: 'config.gradle'

if(project.ext.has('extraConfig')) {
  def extraConfigs = project.ext.extraConfig.split(',')
  for(def extraConfig in extraConfigs) {
    if(!extraConfig.endsWith('.gradle'))
      extraConfig += '.gradle'
    apply from: extraConfig
  }
}

def rootFolder = (project.multiproject.rootFolder ? new File(project.projectDir, project.multiproject.rootFolder).canonicalFile : project.projectDir)

task build
task buildApps
task buildExamples
task gitBranchList
task gitCommit
task gitPush
task gitStatus
task update
task uploadArchives

if(!tasks.findByName('clean'))
  task clean

clean.mustRunAfter update

// automated release feature ++

task releaseChecks, dependsOn: update
task releaseCollectVersions, dependsOn: releaseChecks
task releaseResolveVersions, dependsOn: releaseCollectVersions
task releasePrepareReleaseVersions, dependsOn: releaseResolveVersions
task releaseCheckSnapshotDependencies, dependsOn: releasePrepareReleaseVersions
task releaseBuild, dependsOn: releaseCheckSnapshotDependencies
task releaseCreateReleaseTags, dependsOn: releaseBuild
task releasePrepareNewVersions, dependsOn: releaseCreateReleaseTags
task releaseCommitNewVersions, dependsOn: releasePrepareNewVersions

Map versionMap = [:]

def getProjectKey = { String projName ->
  projName.replaceAll(/[^0-9A-Za-z]/, '_')
}

def getVersionInfo = { String projName ->
  versionMap[getProjectKey(projName)]
}

task ('afterRelease') {
  doLast {
    project.logger.warn 'Release is finished. The following projects were released:'
    project.logger.warn 'Project Name\t| Release Version\t| New Version'
    versionMap.each { projKey, versionInfo ->
      project.logger.warn '{}\t| {}\t\t\t| {}', versionInfo.originalProjectName, versionInfo.releaseVersion, versionInfo.newVersion
    }
  }
}

task('release') {
  dependsOn releaseCommitNewVersions
  finalizedBy afterRelease
}

project.gradle.taskGraph.afterTask { Task task, TaskState state ->
	if (state.failure && task.name =~ /(.+)_build/) {
    project.logger.error 'Release process failed, reverting back all changes:'
    versionMap.each { projKey, versionInfo ->
      project.logger.error ' reverting {}', versionInfo.propertiesFile
      versionInfo.propertiesFile.text = versionInfo.originalPropertiesText
    }
	}
}

// automated release feature --

// first pass, we create per-project tasks
project.multiproject.projects.each { projName, proj ->

  File projFolder = new File(rootFolder, new File(projName).getName())
  
  def projUpdateTask
  if(projFolder.exists()) {
  
    projUpdateTask = task("${projName}_update") {
      update.dependsOn it
      doLast {
        def grgit = Grgit.open(projFolder.absolutePath)
        try {
          grgit.pull()
        } finally {
          grgit.close()
        }
      }
    }
    
    if(proj.branch)
      task("${projName}_checkout") {
        projUpdateTask.dependsOn it
        doLast {
          def grgit = Grgit.open(projFolder.absolutePath)
          try {
            grgit.checkout(branch: proj.branch)
          } finally {
            grgit.close()
          }
        }
      }
  } else {
    def gitSource
    if(proj.gitSource)
      gitSource = proj.gitSource 
    else {
      def gitName = proj.gitName ?: projName
      gitName += proj.gitNameSuffix      
      def gitBase
      if(proj.gitBase)
        gitBase = proj.gitBase
      else if(project.multiproject.gitBase)
        gitBase = project.multiproject.gitBase
      else
        throw new Exception("Don't know from where to clone project '$projName'. Please specify gitBase or gitSource.")
      gitSource = gitBase
      gitSource += proj.gitNameSeparator
      gitSource += gitName
    }
    if(new File(gitSource).exists())
      gitSource = new File(gitSource).toURI().toString()
    projUpdateTask = task("${projName}_update") {
      update.dependsOn it
      doLast {
        def grgit = Grgit.clone(dir: projFolder, uri: gitSource)
        try {
          if(proj.branch) {
            println "DBG branch: ${proj.branch}"
            grgit.checkout(branch: proj.branch, createBranch: true)
          }
        } finally {
          grgit.close()
        }
      }
    }
  }  
  
  boolean shouldBuild = proj.build == null || proj.build
  boolean buildSelfDefined = proj.build == null || (proj.build instanceof Boolean && proj.build)
  def projBuildTask = null
  def projCleanTask = null
  if(shouldBuild) {
    projBuildTask = task("${projName}_build", type: GradleBuild) {
      description = "Builds the project $projName"
      build.dependsOn it
      if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask
      if(buildSelfDefined)
        dir = projFolder
      else {
        proj.build = proj.build.toString()
        if(proj.build.endsWith('.gradle'))
          buildFile = "$projFolder/${proj.build}"
        else
          dir = "$projFolder/${proj.build}"
      }
      tasks = proj.buildTasks ?: [ 'build' ]
    }
    projCleanTask = task("${projName}_clean", type: GradleBuild) {
      description = "Cleans the project $projName"
      clean.dependsOn it
      if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask
      dir = new File(projFolder, isString(proj.build) ? proj.build : '.')
      tasks = [ 'clean' ]
    }
    if(proj.contribs) {
      task("${projName}_installContribs", type: GradleBuild) {
        description = "Installs contributions in project $projName"
        projBuildTask.dependsOn it
        if(projFolder.exists())
          mustRunAfter projUpdateTask
        else
          dependsOn projUpdateTask      
        if(isString(proj.contribs)) {
          proj.contribs = proj.contribs as String
          if(proj.contribs.endsWith('.gradle'))
            buildFile = "$projFolder/${proj.build}"
          else
            dir = "$projFolder/${proj.contribs}"
        }
        else
          dir = "$projFolder/contribs"
        tasks = [ 'install' ]
      }
      task("${projName}_cleanContribs", type: GradleBuild) {
        description = "Cleans contributions in project $projName"
        clean.dependsOn it
        dependsOn projCleanTask
        if(projFolder.exists())
          mustRunAfter projUpdateTask
        else
          dependsOn projUpdateTask      
        if(isString(proj.contribs)) {
          proj.contribs = proj.contribs as String
          if(proj.contribs.endsWith('.gradle'))
            buildFile = "$projFolder/${proj.build}"
          else
            dir = "$projFolder/${proj.contribs}"
        }
        else
          dir = "$projFolder/contribs"
        tasks = [ 'clean' ]
      }
    }
  } else if(!projFolder.exists()) {
    build.dependsOn projUpdateTask
    clean.dependsOn projUpdateTask
  }

  if(proj.examples) {
    task("${projName}_buildExamples", type: GradleBuild) {
      description = "Builds examples in project $projName"
      dependsOn build
      buildExamples.dependsOn it
      if(projBuildTask)
        dependsOn projBuildTask
      else if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask      
      dir = new File(projFolder, isString(proj.examples) ? proj.examples : 'examples')
      tasks = [ 'build' ]
    }

    task("${projName}_cleanExamples", type: GradleBuild) {
      description = "Cleans examples in project $projName"
      clean.dependsOn it
      if(projCleanTask)
        projCleanTask.dependsOn it
      else if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask
      dir = new File(projFolder, isString(proj.examples) ? proj.examples : 'examples')
      tasks = [ 'clean' ]
    }
  }
  
  if(proj.apps) {
    task("${projName}_buildApps", type: GradleBuild) {
      description = "Builds applications in project $projName"
      dependsOn build
      buildApps.dependsOn it
      if(projBuildTask)
        dependsOn projBuildTask
      else if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask
      dir = new File(projFolder, isString(proj.apps) ? proj.apps : 'apps')
      tasks = [ 'build' ]
    }

    task("${projName}_cleanApps", type: GradleBuild) {
      description = "Cleans applications in project $projName"
      clean.dependsOn it
      if(projCleanTask)
        projCleanTask.dependsOn it
      else if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask
      dir = new File(projFolder, isString(proj.apps) ? proj.apps : 'apps')
      tasks = [ 'clean' ]
    }
  }

  if(proj.uploadArchives || buildSelfDefined) {
    def uploadArchivesTask = task("${projName}_uploadArchives", type: GradleBuild) {
      description = "Uploads archives of project $projName"
      dependsOn build
      uploadArchives.dependsOn it
      if(projBuildTask)
        dependsOn projBuildTask
      else if(projFolder.exists())
        mustRunAfter projUpdateTask
      else
        dependsOn projUpdateTask
      dir = new File(projFolder, isString(proj.build) ? proj.build : '.')
      tasks = [ 'uploadArchives' ]
    }
    if(proj.contribs)
      task("${projName}_uploadContribs", type: GradleBuild) {
        description = "Uploads contributions of project $projName"
        uploadArchivesTask.dependsOn it
        if(projFolder.exists())
          mustRunAfter projUpdateTask
        else
          dependsOn projUpdateTask      
        if(isString(proj.contribs)) {
          proj.contribs = proj.contribs as String
          if(proj.contribs.endsWith('.gradle'))
            buildFile = "$projFolder/${proj.build}"
          else
            dir = "$projFolder/${proj.contribs}"
        }
        else
          dir = "$projFolder/contribs"
        tasks = [ 'uploadArchives' ]
      }
  }

  task("${projName}_gitStatus") {
    description = "git status on ${projName}"    
    if(projFolder.exists())
      mustRunAfter projUpdateTask
    else
      dependsOn projUpdateTask
    mustRunAfter update
    gitStatus.dependsOn it
    doLast {
      def grgit = Grgit.open(projFolder.absolutePath)
      try {
        def status = grgit.status()
        def unstaged = status.unstaged
        if(unstaged.added || unstaged.modified || unstaged.removed)
          println '  unstaged:'
        for(def f in unstaged.added)
          println "    added $f"
        for(def f in unstaged.modified)
          println "    modified $f"
        for(def f in unstaged.removed)
          println "    removed $f"
        def staged = status.staged
        if(staged.added || staged.modified || staged.removed)
          println '  staged:'
        for(def f in staged.added)
          println "    added $f"
        for(def f in staged.modified)
          println "    modified $f"
        for(def f in staged.removed)
          println "    removed $f"
      } finally {
        grgit.close()
      }    
    }
  }

  task("${projName}_gitBranchList") {
    description = "git branches on ${projName}"
    if(projFolder.exists())
      mustRunAfter projUpdateTask
    else
      dependsOn projUpdateTask
    mustRunAfter update
    gitBranchList.dependsOn it
    doLast {
      def grgit = Grgit.open(projFolder.absolutePath)
      try {
        def branches = grgit.branch.list()
        for(def branch in branches) {
          print (branch == grgit.branch.current ? '* ' : '  ')
          println branch.name
        }
      } finally {
        grgit.close()
      }    
    }
  }

  task("${projName}_gitCommit") {
    description = "git commit on ${projName}"
    if(projFolder.exists())
      mustRunAfter projUpdateTask
    else
      dependsOn projUpdateTask
    mustRunAfter update
    gitCommit.dependsOn it
    doLast {
      if(!project.ext.has('message'))
        throw new GradleException('Cannot commit: message is not specified')
      boolean amend = project.ext.has('amend') ? (project.ext.amend as boolean) : false
      def grgit = Grgit.open(projFolder.absolutePath)
      try {
        def status = grgit.status()
        if(status.unstaged.added || status.unstaged.modified || status.unstaged.removed || 
           status.staged.added || status.staged.modified || status.staged.removed) {
          project.logger.info 'Committing changes'
          grgit.commit(all: true, message: project.ext.message, amend: amend)
        }
      } finally {
        grgit.close()
      }    
    }
  }

  task("${projName}_gitPush") {
    description = "git push on ${projName}"
    mustRunAfter "${projName}_gitCommit"
    if(projFolder.exists())
      mustRunAfter projUpdateTask
    else
      dependsOn projUpdateTask
    mustRunAfter update
    gitPush.dependsOn it
    doLast {
      def grgit = Grgit.open(projFolder.absolutePath)
      try {
        grgit.push()
      } finally {
        grgit.close()
      }    
    }
  }

  task("${projName}_releaseChecks", type: GradleBuild) {
    description = "Do checks before release of ${projName}"
    mustRunAfter update
    releaseChecks.dependsOn it
    dir = projFolder
    tasks = [ 'checkCommitNeeded', 'checkUpdateNeeded' ]
  }

  task("${projName}_releaseCollectVersions") {
    description = "Collect versions before release of ${projName}"
    mustRunAfter releaseChecks
    releaseCollectVersions.dependsOn it
    doLast {
      File propertiesFile = new File(projFolder, 'gradle.properties')
      if(!propertiesFile.exists())
        throw new GradleException("File ${propertiesFile} does not exist. Could not release.")
		  Properties properties = new Properties()
		  propertiesFile.withInputStream { properties.load(it) }
		  if(!properties.version)
        throw new GradleException("'version' property is not defined in ${propertiesFile}. Could not release.")
		  String releaseVersion
		  if(proj.releaseVersion instanceof String)
		    releaseVersion = proj.releaseVersion
		  else if(proj.releaseVersion instanceof Map)
		    for(def e in proj.releaseVersion) {
		      def m = properties.version =~ e.key
		      if(m) {
            releaseVersion = e.value(m)		      
		        break
		      }
		    }
		  String newVersion
		  if(proj.newVersion instanceof String)
		    newVersion = proj.newVersion
		  else if(proj.newVersion instanceof Map)
		    for(def e in proj.newVersion) {
		      def m = properties.version =~ e.key
		      if(m) {
            newVersion = e.value(m)		      
		        break
		      }
		    }
		  versionMap[getProjectKey(projName)] = [ originalProjectName: projName, propertiesFile: propertiesFile, originalProperties: properties, originalPropertiesText: propertiesFile.text, releaseVersion: releaseVersion, newVersion: newVersion ]
    }
  }

  task("${projName}_releaseResolveVersions") {
    description = "Resolve versions before release of ${projName}"
    mustRunAfter releaseCollectVersions
    releaseResolveVersions.dependsOn it
    doLast {
      def thisVersion = getVersionInfo(projName)
      def releaseProperties = [:] + thisVersion.originalProperties
      releaseProperties.version = thisVersion.releaseVersion
      def newProperties = [:] + thisVersion.originalProperties
      newProperties.version = thisVersion.newVersion
      thisVersion.originalProperties.each { key, value ->
        def m = key =~ /(.+)_version$/
        if(m) {
          def otherProjName = m[0][1]
          def otherProjVersion = getVersionInfo(otherProjName)
          if(otherProjVersion) {
            releaseProperties[key] = otherProjVersion.releaseVersion
            newProperties[key] = otherProjVersion.newVersion
          } else
            project.logger.warn 'File {} contains property {} that refers to a non-existing project {}.', thisVersion.propertiesFile, key, otherProjName
        }
      }
      thisVersion.releaseProperties = releaseProperties
      thisVersion.newProperties = newProperties
    }
  }

  task("${projName}_releasePrepareReleaseVersion") {
    description = "Prepare release version for ${projName}"
    mustRunAfter releaseResolveVersions
    releasePrepareReleaseVersions.dependsOn it
    doLast {
      def thisVersion = getVersionInfo(projName)
      project.logger.warn '{} : {} : setting release version', projName, thisVersion.releaseVersion
      def releaseProperties = new Properties() + thisVersion.releaseProperties
      thisVersion.propertiesFile.withOutputStream { releaseProperties.store(it, null) }
    }
  }

  task("${projName}_releaseCheckSnapshotDependencies", type: GradleBuild) {
    description = "Check for snapshot dependencies before release of ${projName}"
    mustRunAfter releasePrepareReleaseVersions
    releaseCheckSnapshotDependencies.dependsOn it
    dir = projFolder
    tasks = [ 'checkSnapshotDependencies' ]
  }
  
  if(projBuildTask)
    projBuildTask.mustRunAfter releaseCheckSnapshotDependencies

  task("${projName}_releaseBuild") {
    description = "Build ${projName} for release"
    mustRunAfter releaseCheckSnapshotDependencies
    if(projBuildTask)
      dependsOn projBuildTask
    releaseBuild.dependsOn it
  }

  task("${projName}_releaseCreateReleaseTag") {
    description = "Create release tag for ${projName}"
    mustRunAfter releaseBuild
    releaseCreateReleaseTags.dependsOn it
    doLast {
      def thisVersion = getVersionInfo(projName)
      def grgit = Grgit.open(projFolder.absolutePath)
      try {
        if(proj.releaseNoCommit)
          project.logger.warn '{} : {} : releaseNoCommit is set, will not be commited and/or pushed', projName, thisVersion.releaseVersion
        else {
          def status = grgit.status()
          if(status.unstaged.added || status.unstaged.modified || status.unstaged.removed || 
             status.staged.added || status.staged.modified || status.staged.removed) {
            project.logger.warn '{} : {} : committing release version', projName, thisVersion.releaseVersion
            grgit.commit(all: true, message: "Release ${thisVersion.releaseVersion}", amend: false)
          }
          project.logger.warn '{} : {} : creating release tag', projName, thisVersion.releaseVersion
          grgit.tag.add(name: thisVersion.releaseVersion, message: "Release ${thisVersion.releaseVersion}", force: true)
          if(proj.releaseNoPush)
            project.logger.warn '{} : {} : releaseNoPush is set, will not be pushed to upstream repository', projName, thisVersion.releaseVersion
          else {
            project.logger.warn '{} : {} : pushing release version to upstream repository', projName, thisVersion.releaseVersion
            grgit.push(tags: true)
          }
        }
      } finally {
        grgit.close()
      }
    }
  }

  task("${projName}_releasePrepareNewVersion") {
    description = "Prepare new version for ${projName}"
    mustRunAfter releaseCreateReleaseTags
    releasePrepareNewVersions.dependsOn it
    doLast {
      def thisVersion = getVersionInfo(projName)
      project.logger.warn '{} : {} : setting new version', projName, thisVersion.newVersion
      def newProperties = new Properties() + thisVersion.newProperties
      thisVersion.propertiesFile.withOutputStream { newProperties.store(it, null) }
    }
  }

  task("${projName}_releaseCommitNewVersion") {
    description = "Commit new version for ${projName}"
    mustRunAfter releasePrepareNewVersions
    releaseCommitNewVersions.dependsOn it
    doLast {
      def thisVersion = getVersionInfo(projName)
      def grgit = Grgit.open(projFolder.absolutePath)
      try {
        if(proj.releaseNoCommit)
          project.logger.warn '{} : {} : releaseNoCommit is set, will not be commited and/or pushed', projName, thisVersion.newVersion
        else {
          def status = grgit.status()
          if(status.unstaged.added || status.unstaged.modified || status.unstaged.removed || 
             status.staged.added || status.staged.modified || status.staged.removed) {
            project.logger.warn '{} : {} : committing new version', projName, thisVersion.newVersion
            grgit.commit(all: true, message: "New version ${thisVersion.newVersion}", amend: false)
            if(proj.releaseNoPush)
              project.logger.warn '{} : {} : releaseNoPush is set, will not be pushed to upstream repository', projName, thisVersion.newVersion
            else {
              project.logger.warn '{} : {} : pushing new version to upstream repository', projName, thisVersion.newVersion
              grgit.push()
            }
          }
        }
      } finally {
        grgit.close()
      }
    }
  }
    
} // first pass is over

// second pass, now we handle inter-project dependencies
project.multiproject.projects.each { projName, proj ->
  if(proj.dependsOn) {
    def thisProjUpdate = tasks.findByName("${projName}_update")
    def thisProjBuild = tasks.findByName("${projName}_build")
    def thisProjBuildExamples = tasks.findByName("${projName}_buildExamples")
    def thisProjBuildApps = tasks.findByName("${projName}_buildApps")
    def thisProjClean = tasks.findByName("${projName}_clean")
    def thisProjGitStatus = tasks.findByName("${projName}_gitStatus")
    def thisProjReleaseBuild = tasks.findByName("${projName}_releaseBuild")
    toCollection(proj.dependsOn).each { otherProj ->
      def otherProjUpdate = "${otherProj}_update"
      thisProjUpdate.dependsOn otherProjUpdate
      if(thisProjBuild) {
        def otherProjBuild = tasks.findByName("${otherProj}_build")
        if(otherProjBuild)
          thisProjBuild.dependsOn otherProjBuild
        else if (!file(otherProj).exists())
          thisProjBuild.dependsOn otherProjUpdate
      }
      if(thisProjBuildExamples) {
        def otherProjBuild = tasks.findByName("${otherProj}_build")
        if(otherProjBuild)
          thisProjBuildExamples.dependsOn otherProjBuild
        else if (!file(otherProj).exists())
          thisProjBuildExamples.dependsOn otherProjUpdate
      }
      if(thisProjBuildApps) {
        def otherProjBuild = tasks.findByName("${otherProj}_build")
        if(otherProjBuild)
          thisProjBuildApps.dependsOn otherProjBuild
        else if (!file(otherProj).exists())
          thisProjBuildApps.dependsOn otherProjUpdate
      }
      if(thisProjClean) {
        def otherProjClean = tasks.findByName("${otherProj}_clean")
        if(otherProjClean)
          thisProjClean.dependsOn otherProjClean
        else if (!file(otherProj).exists())
          thisProjClean.dependsOn otherProjUpdate
      }
      thisProjGitStatus.dependsOn "${otherProj}_gitStatus"
      thisProjReleaseBuild.dependsOn "${otherProj}_releaseBuild"
    }
  }
}

defaultTasks 'buildApps'

